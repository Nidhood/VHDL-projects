LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY parking_count_bist IS
    PORT (
        clk     : IN STD_LOGIC;
        rst     : IN STD_LOGIC;
        sensor0 : OUT STD_LOGIC;
        sensor1 : OUT STD_LOGIC
    );
END ENTITY;

ARCHITECTURE bist_arch OF parking_count_bist IS
    TYPE state IS (idle, car_ent1, car_ent2, car_ent3, pause, car_ext1, car_ext2, car_ext3, done);
    SIGNAL current_state, next_state : state;
    SIGNAL counter : INTEGER RANGE 0 TO 20 := 0;
BEGIN

    -- Proceso de transición de estados
    PROCESS (clk, rst)
    BEGIN
        IF rst = '1' THEN
            current_state <= idle;
        ELSIF rising_edge(clk) THEN
            current_state <= next_state;
        END IF;
    END PROCESS;

    -- Proceso de generación de estímulos
    PROCESS (current_state, counter)
    BEGIN
        sensor0 <= '0';
        sensor1 <= '0';
        next_state <= current_state;

        CASE current_state IS
            WHEN idle =>
                next_state <= car_ent1;

            WHEN car_ent1 =>  -- Sensor0 activado
                sensor0 <= '1';
                next_state <= car_ent2;

            WHEN car_ent2 =>  -- Ambos sensores activados
                sensor0 <= '1';
                sensor1 <= '1';
                next_state <= car_ent3;

            WHEN car_ent3 =>  -- Solo sensor1
                sensor1 <= '1';
                next_state <= pause;

            WHEN pause =>  -- Espera
                IF counter = 5 THEN
                    next_state <= car_ext1;
                END IF;

            WHEN car_ext1 =>  -- Sensor1 activado
                sensor1 <= '1';
                next_state <= car_ext2;

            WHEN car_ext2 =>  -- Ambos sensores activados
                sensor0 <= '1';
                sensor1 <= '1';
                next_state <= car_ext3;

            WHEN car_ext3 =>  -- Solo sensor0
                sensor0 <= '1';
                next_state <= done;

            WHEN done =>
                next_state <= done;

        END CASE;
    END PROCESS;

    -- Contador de pausa
    PROCESS (clk, rst)
    BEGIN
        IF rst = '1' THEN
            counter <= 0;
        ELSIF rising_edge(clk) THEN
            IF current_state = pause THEN
                counter <= counter + 1;
            ELSE
                counter <= 0;
            END IF;
        END IF;
    END PROCESS;

END ARCHITECTURE;
